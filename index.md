# Basics of the Unix Philosophy for life

{:toc}

## Modularity: Write simple parts connected by simple language

> The only way to tackle complex issues that won’t fall apart is to keep global complexity down. Instead, foster simple parts connected by well-defined communication channels and understandable language, so most problems are local to a specific part and there are opportunities for updating one part without breaking the whole.

## Clarity: Clarity is better than cleverness

> Write policies as if the most important communication they have is not to the system but to the people who will live them out, implement and maintain them in future (including yourself). Making the key points graceful and clear to ensure that they’re less likely to be interpreted wrongly.

## Composition: Create systems to be connected to other programs

> To make systems composable, decouple them. A system or individual at one end of a process should know only what is *absolutely necessary* about the processes of the system at the other end—they should not depend on it. It should be easy to replace one end with a newer, updated or different system without disturbing the other end.

## Separation: Separate policy from implementation; separate idealism from action

> Policy and implementation tend to mutate at different timescales, with policy changing much faster than the ability to implement it. Political and social trends and fashions come and go, but basic human needs, methods of implementation and psychology change very little.

## Simplicity: Design for simplicity; add complexity only where you must

> encourage a culture that knows that small is beautiful, that actively resists bloat and complexity: a tradition that puts a high value on simple solutions, that looks for ways to break systems up into small cooperating pieces, and that reflexively fights attempts to add anything that has no beauty, meaning or function.

## Parsimony: Create big things only when it is clear by demonstration that nothing else will do

> ‘Big’ means both large in volume, and by internal complexity. Allowing structures—social or material—to get too large hurts maintainability. People are reluctant to throw away the visible product or time investment put into what they work on and with, but overly large structures invite over-investment in approaches that can fail spectacularly or become suboptimal and hard to update.

## Transparency: Design for visibility to make inspection and correction easier

> A system is transparent when you can look at it and immediately understand what it is doing and how. It is discoverable when it has facilities for monitoring and can display its internal state so that it not only functions well, but can be *seen* to function well. Use the principle of least surprise by appealing to peoples’ pre-existing knowledge and assumptions.

## Robustness: the child of transparency and simplicity.

> Large systems tend to be fragile and error-prone because they’re too complicated for human understanding to grasp all at once. When the internal workings of a system are obscure or not open to scrutiny, you can’t be sure it’s fair, or fix it if it’s broken. Robust systems work best when they’re uncomplicated enough for people to reason about their processes without struggling to understand them.

## Representation: Fold knowledge into data so people don’t need to work out what to do.

> Hide complexity in data, but keep procedures on data simple (e.g. make it easy to edit). Store acquired knowledge as data for others to access—staff turnover loses valuable experience and wisdom if not captured from on-the-ground knowledge. Well-structured data is easier to understand than complex procedures. Simplify presentation into unabmiguous chunks that can be seen at a glance. We don’t always need to grasp every detail, but where more knowledge is requested, set up pointers to enable people to travel from any facet to specific in-depth details.

## Silence: When there’s nothing surprising to say, say nothing.  

> when a system has nothing interesting or surprising to say, it should shut up. Well-behaved systems (and departments) do their jobs unobtrusively, with a minimum of fuss and bother. Important information should not be polluted by verbosity about internal organisational behavior, catchphrases, acronyms, congratulations, personal messages and so on. People don’t need any more information than they require to do what they need to do, so share only what’s crucial and essential.

## Repair: When you must fail, fail noisily and as soon as possible.

> Don’t conceal errors—the sooner they’re revealed, the quicker they can be fixed. If something doesn’t work as expected, make the issue public to prevent it escalating to other areas. If the cause appears to be generated by people, something is misleading them into making a mistake. Encourage error-reporting so people share problems they’re having. Shift repsonsibility towards the system as the point of failure. People don’t need to feel “stupid for making a mistake”, if a system *allows mistakes* to be made. Every confused user who reports a problem is a valuable ally towards improvement in quality.

## Everyone’s time is expensive; conserve their time in preference to time spent on system administration

> Don’t laboriously undertake tasks manually when they can be handled at a less complex level. Create routines that automate repetitive or offer step-by-step guides to cognitively-demanding jobs so that others can follow them easily without learning how they work (unless that’s part of their job). Whereever tedious system administration can be automated, make it possible either for someone to instruct a machine to do the work, following a previously-tested procedure, or set up a machine to check for certain triggers (e.g. time- or date-sensitive) that initiate and complete this administration automatically, possibly informing someone afterwards that it’s done.
> 
> This leads to…

## Generation: avoid guesswork when creating automated processes, ensure they produce error-free outcomes and can be undone if in error

> Human beings are notoriously bad at processing details… any kind of procedure that depends on individual input is a rich source of delays and errors. The simpler and more abstracted the guidelines, the more likely it is that the human designer will get it right. Time-tested automated procedures (at every level) are almost always cheaper and more reliable than hand-operated ones. So use automated generators of output or simple guides when they can raise the level of abstraction — that is, when the guidelines to operate an automated process can be made simpler than the underlying process itself. No-one needs to be held back by unecessary details that can be automated. To be absolutely sure, store or record the current state to enable a “rollback” for any change, just in case.

## Optimize: prototype things as soon as possible; get stuff working instead of trying to make it perfect

> don’t delay by planning every detail of something top-down from the start - you won’t be able to predict what might need to be done once other people or teams get involved. Get things up and running, then bring in and let the people who will use the system/thing/process try it out and give you feedback. Resist changing anything until here’s enough concrete feedback from those involved to ensure that any change improves the operation, or people’s experience of it as operators or recipients of a service or process. To sum up: “Make it work, then make it right, then make it easy”. It’s better to deliver a 90% of something than fail to deliver anything at all. Let people try it out, make adjustments based on their feedback or where bottlenecks appear, try again, and repeat.

---

** ============== DONE TO HERE ============== **

## Diversity: Distrust all claims for “one true way”.

> Nobody is smart enough to optimize for everything, nor to anticipate all the uses to which their software might be put. Designing rigid, closed software that won’t talk to the rest of the world is an unhealthy form of arrogance. …the Unix tradition […] embraces multiple languages, open extensible systems, and customization hooks everywhere.

## Extensibility: Design for the future, because it will be here sooner than you think.

> Never assume you have the final answer. Therefore, leave room for your data formats and code to grow… Always, always either include a version number, or compose the format from self-contained, self-describing clauses in such a way that new clauses can be readily added and old ones dropped without confusing format-reading code. Make data layouts self-describing… When you design code, organize it so future developers will be able to plug new functions into the architecture without having to scrap and rebuild the architecture. Make the joints flexible, and put “If you ever need to…” comments in your code. When you design for the future, the sanity you save may be your own.
